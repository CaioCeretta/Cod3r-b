# Overall comments about the project

## Some explanations may be on the docs folder, utilizing diagrams

  ● The instructor opted by creating the front-end first for us to have a visual feedback

  ● docs folder and project planning
    ○ Inside the docs folder, we've created an `interface.excalidraw` 
    ○ First, we'll worry about registering a vote inside the app
    ○ Then, eventually we are going to create a CRUD for registering candidates, parties, voters, etc

  ● Inside src, we can create a data folder, where will be placed codes like the models and constants so we can initially
  mock the data for us to access them through the workspace and later think on databases.

    ○ We also can, in the future, refactor the project, and move this model to another project, because in the future we
    can create a folder to separate the model to the front end.

    ○ However, the focus is, to put the codes in a more simple manner, and refactor along with the coding, the focus is
    to understand how to start a project, which is a tunnel with a curve, we won't necessarilly see the end of it and how
    it will end, we "walk with it" make the adjustements, and at the end, see the project output

  ● App folder will be responsible to hold our UI/Pages the app will eventually have.  

  ● Start by creating the data/model/Candidate.ts, which, for the first moment, is going to be an interface not a class
  and eventually, the code will start evolving.
    ○ Create the candidates.ts inside constants with the json generated by gpt

  ● Inside components folder, create the folder to separate the components we are going to work with on each pae,

  ● Inside app, where we will have our pages, and create folder (groups) for a better separation.

    ○ app/(admin) <- Only for administration pages
      ■ Which in this folder, we can separate into candidates and voters
    ○ add/(voting) <- Specific folder for who works and make use of the voting interface
    
  ● Within the components folder, create a new folder shared, with components to be used across different pages, and inside
  it, create a component Page.tsx, which will be used as layout to our application

  ● Create a .container class on our global.css and use this class inside the main tag of div, and on other classes to
  maintain the width

  ● For excluding candidates, the delete candidate function could not belong to the list of candidates, since it do not
  "own" the state. Therefore, what we have to pass down a function to the children for indirect communication.

  ● After finishing the frontend project, there are several ways we can scale it to also include a separate backend
  project

    ○ In the project root, create a package.jon file outside of all individual projects, and use Node's workspace feature
      ■ a folder that contains multiple projects. This allows us to create both the frontend and backend, as well as share
      share code between them. A common approach is to have a core folder, which does not contain any application or
      framework-specific logic, but only utility libraries such as `uuid`. This way we can keep our business rules in one
      place and use them separately in different applications.
      ■ There also an option of placing every project into an apps folder and within package.json workspace simply use
      workspaces: ["apps/*"], since apps will not be considered a node project in the workspace
      ■ It will be a project in a single repository with both the applications that are going to be deployed, and also
      internal packages that we are willing to reuse between projects.

      ■ This node workspace is similar to turborepo, however, turborepo automates some things, such as separating consoles
      for each application being ran.
        □ Behind the curtains turbo-repo uses node workspaces. But adds some other features.

      ■ We will also create a packages folder for holding the core module and our graphics, and initially, it will be
      {
        "name": "urna",
        "version": "1.0.0",
        "workspaces": [
          "apps/*",
          "packages/*"
        ]
      }

      ■ Within the core package, in the package.json, we need to make the main property to point to the main attribute of
       our package
        □ to understand how a function from a project, is available to other applications, we will follow these steps
          1 - Create a simple function inside the main file of printing a string
          2 - Within the frontend's package.json, we are now going to treat the core package as a dependency package and
          use the name defined in core's package.json. Since we now depend on the core package, we simply add something
          like: 

            "dependencies": {
              "@urna/core": "*",
              ...
            }

          3 - And to make use of it, within our project root, outside all apps, install this package with npm install,
          since even though it is an internal package, it needs to make the necessary adjustements

          4 - We can now import the function exported by core, simply as importing a normal library as we are used to.
      
          5 - For running all apps at once, inside the outer package.json, we can install a library named `npm-run-all`
          and create new scrips

            . dev script where it runs in paralell all the scripts that start with dev, with a run-p dev:* , this will
            make it unnecessary to go into each folder and run the dev script

            . we can also explicitly say that a dev:frontend script will go into the frontend folder and run the dev
            with "cd apps/frontend && npm run dev"

            . with the dev script running in parallel all dev scripts from the workspaces, we run all together

  ● Layout errors

    ○ I, personally, faced  an error, where i was not sure how to place the layouts correctly, and this is going to be
    registered for me to not make the same mistake again

    ○ In Next.js App router, only the root layout `app/layout.tsx` is responsible for defining the <html> and <body> tags
    of the entire application, and here are some mistakes we can make

      ■ 1 - Creating the app/layout.tsx  like

        ```ts
          export default function RootLayout({
              children,
          }: Readonly<{
              children: React.ReactNode
          }>) {
              return (
                  <html lang="pt-BR">
                      <div>{children}</div>
                  </html>
              )
          }
        ```

      □ Here we end up defining an invalidHTML, since div was directly inside html without a <body> tag between\

      □ Browsers will ttry to fix this automatically by inserting a <body> element for us, but this breaks the expected
      structure of the App.ROuter in particular

        1. Next.js expects the body tag to be in our root layout, so it can properly inject scripts
        2. Skipping <body> means our layout is technically malformed
        3. Adding <html> in route-group layouts (like `(admin)/layout.tsx`) makes the problem worse because we'd be trying
        to render a full HTML document inside another HTML document, which is invalid
    
    ■ Correct approach

      □ define <html> and <body> exactly one in the app — In the root layout
      □ Any nested layouts, like the admin one, do not use <html><body>, just wrap the children in UI structure components,
      such as Page
      □ This will avoid hydration errors by Next.js

● Specific Components

  ○ One important thing when creating specific components, is not to limit its uses by taking off everything that one component
  has, its flexibility. When defining the properties of a button component we've created, for example, it is important to
  us to, in the interface, consider all existing properties within a button and place them inside our button so it can
  support all these necessities.
    This is why the instructor often follows the approach of creeating a specific component, but since in the app we're
  building, the goal is to simplify most of it, he ended up having the idea of creating a css class to be used inside purely
  html tags.

● Wrapping the main layout with the Context Provider

  ○ This is not considered the best approach, in the ideal scenario we would transform the layout return to be a client
  component, for this, we are going to create a folder (paginas) and place all our routs inside of this folder

  ○ We are going to do this, because this way, we can create a single layout file for all the pages within the app, this
  layout is going to be a client one since it will use a context provider

● Should the User model be an interface or a class? 

  ○ The user model, which in the beginning as an interface, usually it is a class. But for simplifying the code at the
  first moment, we are going to use it as an interface.
    
  ○ One question that may arise is: "Ok, now, how i will create this class?". If we just create a class with attributes
  and get/set methods, at the end of the day, it is basically the same as an interface, but if we want to insert some
  rich behaviors (methods), it makes more sense to turn it into a class that represent that model.

● Context function

  ○ If we define a function to update some state data, and this function is defined to have the same type as the useState
  is typed, if no further processing is done to the parameter, we can simply use this setter function as the function

  e.g.

    ■ const [usuario, setUsuario] = useState<Partial<Usuario>>({} as any);
      □ state is typed as a partial user

    ■ 	alterarUsuario: (usuario: Partial<Usuario>);
      □ Context properties have a function with the same type as the state

    ■ on the values object, passed to the provider we can simply
    value={{
				usuario,
				alterarUsuario: setUsuario,
			}}

  ○ Basically, when we do const [usuario, setUsuario] = useState<Partial<Usuario>>({} as any). React infers it as

    ■ usuario: Partial<User>; setUser: React.Dispatch<React.SetStateAction<Partial<User>>>;
    ■ Which means that the setUser is not only a function which receives a Partial<User>, it actually has the signature
    of: 
      □ type SetUsuario = (value: Partial<Usuario> | ((prev: Partial<Usuario>) => Partial<Usuario>)) => void;
      □ This means that we can directly pass a Partial<Usuario> object with, for example, setUser({ name: "Caio"});
      □ Or a function that receives the older state setUser(prev => {...prev, age: 29})

    ■ Inside the context, we define that the alterarUsuario is a function that receives a Partial<Usuario> and does not
    return anything

    ■ So, in the end, it makes sense using the setUser as the same function because setUsuario is more generic than the
    alterarUsuario typing
      □ setUsuario accepts a Partial<Usuario> or a function
      □ alterarUsuario accepts only a Partial<Usuario>
      □ Therefore, when we pass this function in the context value for the alterarUsuario, ts accepts it because any place
      that expects for a user: Partial<Usuario> can receive the setUser, since passing a partial is a case it accepts. it
      is just like a subset of a bigger function

    ■ In summary we can use setUsuario because its typing of Dispatch<SetStateAction<T>> is broader than the one which
    alterarUsuario typed. Since it accepts a Partial<Usuario> directly, ts considers it valid

  ○ Input blocked when using different state for the same input value

    ■ 1. We have two different states for the same input
      □ Created a local state for password, with a useState
      □ But in the value of the input, we are not using this password, but the property password of another object

    ■ 2. React locks the input because it is controlled
      □ A controlled <input> in React should have its value tied to the same state we update in onChange

    ■ To fix it, we just need to bind the value to the same state we're updating

    ■ Other thing that would cause the input to be "locked" is by removing the onChange which changes the state of the
    value, such as
    <input value={nameState} onChange={(e) => setNameState({})}>
    we are no longer able to alter this input value, since the first step of changing a value in a form is by altering
    the state which this attribute is looking to

● env variables

  ○ In next.js, all env variables that start with NEXT_PUBLIC_ are exposed to the front-end, so in our case, even though
  nest and next have similar names, `NEXT_PUBLIC_API_URL` wasn't a typo, this env variable is the front end way of accessing
  the nest api routes

● String is not a valid JSON

  ○ We created a method for interacting with the DB via the frontend, we sent a request for a hook in our frontend, it called
  the backend and return the backend's route return
    However, when trying to convert the simple string of "Hello World" into a JSON, it would return an error saying that
  "Hello World" is not a valid JSON
  
  ○ To fix this, there are no need to change our hook, but yes the backend controller who should return an object and not
  just a string, since the response.json() after the fetch only works in value/pair objects

● Import and Import Type

  ○ 1. Import

    ■ When is it used: e.g. import { User } from "./user";

      □ Typescript will generate a real require on compiled JS
        . Compiled example.
            
  ```js
             "use strict";
             Object.defineProperty(exports, "_esModule", { value: true });
             const user_1 = require("./user");
  ```

      □ This is:
        ▢ user.ts file will really be loaded on runtime
      
    ■ Implication
      □ Even if we use `User` only as type, the whole module is still included in the bundle/runtime
      □ Useful when you need the runtime value (e.g., new User(), UserService, decorators like in NestJS)

  ○ 2. Import type

    ■ When it is used: 

      □ For types only, not runtime values.
      Example:

        ```ts
          import type { User } from "./user"
        ```

    ■ What happens after compilation:

      □ Typescript erases the import completely. Meaning nothing remains in compiled JS

        . No require, no import -> the referenced file will not be loaded
    
    ■ Implication

      □ Makes it explicit that we're only depending on the **shape of the type** 
      □ Can reduce bundle size and prevent circular dependency issues.
      □ x But if that symbol is needed at runtime (e.g. in dependency injection frameworks like NestJS), 
      **using import type will break our app**

  ○ 1. When to use each

    ■ Use import type when: 

      □ We are sure the symbol is only used in type annotation
      □ Example:
      
    ```ts
      import type { User } from "./user";
        function printUser(user: User) {
          console.log(user.name)
        }
    ```

    ■ Mixed case (with import type helper): 

      ```ts
        import { type User, createUser } from "./user"
      ```
    □ createUser is runtime
    □ User is erased (type-only)

  ○ 4. Summary

    ■ import -> runtime + type (generates code)
    ■ import type - type-only (erased, no runtime code)
    ■ Choosing the wrong can either bloath the bundle (using import unnecessarily) or break runtime features (using import
    type when value is required, like NestJS DI)

● Large Applications and Big Complexity Levels

  ○ When developing an app, our architecture may increase its formality level, bringring more structure to it, and the
  project may become more coupled, and with the team not knowing how to specify limits and it can be hard to work with
  it.   

  ○ However, when we bring a structure to the project, even though there are its negative sides, since it is not pleasurable
  to create a protection layer between our business rule and the frameworks, and this means that there is a cost and effort
  involved in this.
    Instead of simply programming in only one file, we separate in four our more files so that we are able to create
  this separation and then have its benefits. But here will be a question of sensibility to see if an already established
  pattern can be applied into the project context, team context, which will may require adptat given patterns to the team
  adhere the pattern and follow these rules in a way the whole team understand what is being done.
    Sometimes we apply the codes in a very cartesian/mathematical manner but this may not be always the best choice for
  the app or team.
    The structure in this project is an intermediate structure, we didn't mix the codes, when thinking of the front-end
  and the back-end, as well as the authentication and the business rules. Because the quantity of modules, and separations
  that we will have and thinking on a strategic way. This whole thinking on require a maturity to us, to understand the
  business without mixing contexts and treating everything as one thing.

● Integrate our API with the use cases and the persistence 

  ○ Up until now, we have already created a schema, with a User table. One thing we can do when dividing our app into
  multiple modules is to create one schema file per module. For example, we can have an `auth.prisma` file only for authentication
  related tables, and other one called `core.prisma` for core tables related to our core entities such as candidates, voters
  and the election. This way, we separate the business domain into smaller parts, including the main schema.

  ○ An interesting point, when thinking about data modeling and app modeling, is that sometimes two entities may not have
  may not have direct relationship, but they do in the app model. It is not required that the database schema (ER model)
  be a mirror of our object-oriented model. In fact, for instance, in some projects the attribute names inside objects are
  copied directly from the database column names, the exact same name of the db column names, such as `nm_user`, `txt_description`
  or id_something. These naming conventions may have sense for database design, but they should not necessarily be carried
  over to te object-oriented domain. Database modeling and application modeling should be independent, since even the way
  relationships are expressed differs significantly.

  ○ In a database, there is essentially one mechanism of relationship: one-to-many. Every other type of relationship derives
  from it. For example:
    
    ■ To simulate a one-to-one relationship, we creae a one-to-many and then add a `UNIQUE` constraint to the foreign key
    column.

    ■ A many-to-many relationship is nothing more than two one-to-many relationships with an intermediate table linking
    them. Therefore, at the database level, the mechanism is always the same: a primary key from one table becomes a foreign
    key in another.
  
  ○ In contrast, in object-oriented design we explicitly model different types of relationship including unidirectional
  and bidirectional associations. In ER modeling, however, all relationships are inherently unidirectional. That's why
  database modeling and application modeling should be treated different

  ○ It is common for teams to start system design from the database, but this is often not the best approach. If we model
  based on the database first, our thinking becomes too data-oriented and constrained by the database technology. For example
    
    ■ If it is a document-based database, we think in terms of documents.
    
    ■ If it is a relational ER database, we think in terms of relations. In both cases, the application becomes coupled to
    the database.

  ○ Instead, we should think in a business-oriented way, focusing on flows, processes, and behaviors that modify the state
  of objects. That's why it is important to maintain separation between database modeling and application modeling—and this is also why ORMs exist.
  
  ○ Continue in the apps/backend db module

● DTS flag in tsup

  ○ In tsup (the ts bundler), the flag --dts or the option dts:true in tsup.config.ts is used to generate type declaration
  fyles (.d.ts) along with the bundle

  ○ This is important when we are creating a library or package that will be used by other ts projects because:
    ■ The transpiled JavaScript does not contain information of types
    ■ The .d.ts files describe the types of each function, class, constant, etc.\

  ○ Practical example

    ■ If we have
      ```
        export function sum(a: number, b: number) {
          return a + b;
        }
      ```

      □ When running tsup with dts: true, besides generating dist/math.js, it generates

        ```ts
          export declare function sum(a: number, b: number): number;
        ```
      
        Which means that dts is just the types outputs of the bundle

  ○ Why did i need to go inside the given package and run a build, to generate the dist folder, when both execute tsup
  `src/index.ts, --dts`?

    ■ The main difference between build and dev is that build uses the --minify flag and dev uses --watch flag, but
    why does it matter when creating the dist folder? 

      □ What does --minify do? 

        . Under the hood, it uses esbuild to compress the output
        . Reduce internal variable names (When possible)
        . Removes commentaries
        . Does some code simplifying

        . Quick Example

          ```
            export function sum(a: number, b: number) {
              return a + b;
            }
          ```

          - Without minifying

            ```
              "use strict";
              Object.defineProperty(exports, "__esModule", { value: true });
              exports.soma = soma;
              function soma(a, b) {
                return a + b;
              }

          - With --minify

          ```
          "use strict";Object.defineProperty(exports,"__esModule",{value:!0});function o(r,e){return r+e}exports.soma=o;
          ```  

      ■ Therefore, it does not change anything in the behavior, it is useful for production since the package becomes smaller
      and in dev, we normally avoid minifying, since it difficults the debug and there won't be a real performance benefit
      during development

      ■ With this being said, --minify has nothing to do with the dist creation. What changes is how --watch works

        □ 1. tsup --watch
          . It does not run a full initial build by default.
          . It only enters on the mode "watching updates"
          . If here is nothing already compiled in `dist`, we will get an empty folder
        
        □ 2. minify
          . runs a full build, generating .js + .d.ts, and only then, finishes
          . since it does not have a --watch, we will always leave with a empty dist

        □ 3. What happens with dev in our case

          . We were running `tsup src/index.ts --dts --watch`.
          . tsup directly enters in watch mode, but no creating an initial dist
          . When next.js tried to import @urna/shared, there was no `dist/index.js` yet, so we got the Cannot find module
          ... dist/index.js error.

        □ Standard Fix in Monorepos

          . Option 1 - run build first, then watch with npm run build && npm run dev
          . Option 2 - insert the new dev:shared script to root package.json, so it ensures its build
          . Option 3 - add --clean flag so tsup ensures an initial build
          . Option 4 - use a tsup.config.ts file configure it to always tart with a clean + initial build

            ```
              import { defineConfig } from 'tsup'

              export default defineConfig({
                entry: ['src/index.ts'],
                dts: true,
                clean: true,
                watch: process.env.NODE_ENV === 'development',
              })
            ```

● Hexagonal Architecture

  ○ Hexagonal architecture (Also called Ports and Adapters) was proposed by Alistair Cockburn. The main idea is to separate
  the application core (business rule) from the ways outside world interacts with it

    ■ Core (App Domain) -> Our pure business rules, independent of frameworks, databases, external API, etc.
    ■ Ports -> Interfaces that define how som,ething external can interact with the core.
      □ Example: A user repository can be defined as an interface `UserRepository` without worriying if the data is coming
      from a SQL, NoSQL or API
    ■ Adapters -> Concrete implementations of these ports.
      □ Example: UserRepositoryPostgres or UseRepoositoryInMemory

  ○ Simple analogy

    ■ Imagine our house (the application core)
    ■ We have different doors: the front door, the back door, the garage
    ■ Each door is a contract (interface) that defines how something can get in or out
    ■ What goes through the door can vary
      . A person through the front door
      . A car through the garage
    
    In an application: 
      . A port (interface) defines the contract (what is allowed to pass).
      . An adapter is what implements that contract (a person, a car, a database, an API)


● `Candidato` Register and Votacao module

  ○ A Candidate is part of the core

    ■ When we want to register the candidate to the db, even though we are separating the code in parts, a candidate is
    part of our core, and maybe using the name core to it is bad, since core is a generic name and it could be better
    if we created a voting module to it. It would be more interesting, because it has the candidate, the voting, the election
    and so on. So because of it, we are changing the core package folder to `votacao`, and change its package.json as
    @urna/votacao

    ■ Everywhere we have the @urna/core dependency we are going to change to @urna/votacao, as well as on the root dev:core
    that enters the core folder
    
    ■ Inside src, create a new `Candidato` which will be similar to auth's user, it will have the model/Candidato.ts file
    and the RepositorioCandidato within the candidato/interface folder

  ○ Within hexagonal architecture, an intrerface is a "port" and a "port" is an entry point that allows us to us to plug
   something into the core of our application

  
    




   





    





    


  

  
  
  










  














