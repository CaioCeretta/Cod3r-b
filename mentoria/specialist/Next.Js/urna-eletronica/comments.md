# Overall comments about the project

## Some explanations may be on the docs folder, utilizing diagrams

  ● The instructor opted by creating the front-end first for us to have a visual feedback

  ● docs folder and project planning
    ○ Inside the docs folder, we've created an `interface.excalidraw` 
    ○ First, we'll worry about registering a vote inside the app
    ○ Then, eventually we are going to create a CRUD for registering candidates, parties, voters, etc

  ● Inside src, we can create a data folder, where will be placed codes like the models and constants so we can initially
  mock the data for us to access them through the workspace and later think on databases.

    ○ We also can, in the future, refactor the project, and move this model to another project, because in the future we
    can create a folder to separate the model to the front end.

    ○ However, the focus is, to put the codes in a more simple manner, and refactor along with the coding, the focus is
    to understand how to start a project, which is a tunnel with a curve, we won't necessarilly see the end of it and how
    it will end, we "walk with it" make the adjustements, and at the end, see the project output

  ● App folder will be responsible to hold our UI/Pages the app will eventually have.  

  ● Start by creating the data/model/Candidate.ts, which, for the first moment, is going to be an interface not a class
  and eventually, the code will start evolving.
    ○ Create the candidates.ts inside constants with the json generated by gpt

  ● Inside components folder, create the folder to separate the components we are going to work with on each pae,

  ● Inside app, where we will have our pages, and create folder (groups) for a better separation.

    ○ app/(admin) <- Only for administration pages
      ■ Which in this folder, we can separate into candidates and voters
    ○ add/(voting) <- Specific folder for who works and make use of the voting interface
    
  ● Within the components folder, create a new folder shared, with components to be used across different pages, and inside
  it, create a component Page.tsx, which will be used as layout to our application

  ● Create a .container class on our global.css and use this class inside the main tag of div, and on other classes to
  maintain the width

  ● For excluding candidates, the delete candidate function could not belong to the list of candidates, since it do not
  "own" the state. Therefore, what we have to pass down a function to the children for indirect communication.

  ● After finishing the frontend project, there are several ways we can scale it to also include a separate backend
  project

    ○ In the project root, create a package.jon file outside of all individual projects, and use Node's workspace feature
      ■ a folder that contains multiple projects. This allows us to create both the frontend and backend, as well as share
      share code between them. A common approach is to have a core folder, which does not contain any application or
      framework-specific logic, but only utility libraries such as `uuid`. This way we can keep our business rules in one
      place and use them separately in different applications.
      ■ There also an option of placing every project into an apps folder and within package.json workspace simply use
      workspaces: ["apps/*"], since apps will not be considered a node project in the workspace
      ■ It will be a project in a single repository with both the applications that are going to be deployed, and also
      internal packages that we are willing to reuse between projects.

      ■ This node workspace is similar to turborepo, however, turborepo automates some things, such as separating consoles
      for each application being ran.
        □ Behind the curtains turbo-repo uses node workspaces. But adds some other features.

      ■ We will also create a packages folder for holding the core module and our graphics, and initially, it will be
      {
        "name": "urna",
        "version": "1.0.0",
        "workspaces": [
          "apps/*",
          "packages/*"
        ]
      }

      ■ Within the core package, in the package.json, we need to make the main property to point to the main attribute of
       our package
        □ to understand how a function from a project, is available to other applications, we will follow these steps
          1 - Create a simple function inside the main file of printing a string
          2 - Within the frontend's package.json, we are now going to treat the core package as a dependency package and
          use the name defined in core's package.json. Since we now depend on the core package, we simply add something
          like: 

            "dependencies": {
              "@urna/core": "*",
              ...
            }

          3 - And to make use of it, within our project root, outside all apps, install this package with npm install,
          since even though it is an internal package, it needs to make the necessary adjustements

          4 - We can now import the function exported by core, simply as importing a normal library as we are used to.
      
          5 - For running all apps at once, inside the outer package.json, we can install a library named `npm-run-all`
          and create new scrips

            . dev script where it runs in paralell all the scripts that start with dev, with a run-p dev:* , this will
            make it unnecessary to go into each folder and run the dev script

            . we can also explicitly say that a dev:frontend script will go into the frontend folder and run the dev
            with "cd apps/frontend && npm run dev"

            . with the dev script running in parallel all dev scripts from the workspaces, we run all together




