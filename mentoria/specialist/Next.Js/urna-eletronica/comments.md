# Overall comments about the project

## Some explanations may be on the docs folder, utilizing diagrams

  ● The instructor opted by creating the front-end first for us to have a visual feedback

  ● docs folder and project planning
    ○ Inside the docs folder, we've created an `interface.excalidraw` 
    ○ First, we'll worry about registering a vote inside the app
    ○ Then, eventually we are going to create a CRUD for registering candidates, parties, voters, etc

  ● Inside src, we can create a data folder, where will be placed codes like the models and constants so we can initially
  mock the data for us to access them through the workspace and later think on databases.

    ○ We also can, in the future, refactor the project, and move this model to another project, because in the future we
    can create a folder to separate the model to the front end.

    ○ However, the focus is, to put the codes in a more simple manner, and refactor along with the coding, the focus is
    to understand how to start a project, which is a tunnel with a curve, we won't necessarilly see the end of it and how
    it will end, we "walk with it" make the adjustements, and at the end, see the project output

  ● App folder will be responsible to hold our UI/Pages the app will eventually have.  

  ● Start by creating the data/model/Candidate.ts, which, for the first moment, is going to be an interface not a class
  and eventually, the code will start evolving.
    ○ Create the candidates.ts inside constants with the json generated by gpt

  ● Inside components folder, create the folder to separate the components we are going to work with on each pae,

  ● Inside app, where we will have our pages, and create folder (groups) for a better separation.

    ○ app/(admin) <- Only for administration pages
      ■ Which in this folder, we can separate into candidates and voters
    ○ add/(voting) <- Specific folder for who works and make use of the voting interface
    
  ● Within the components folder, create a new folder shared, with components to be used across different pages, and inside
  it, create a component Page.tsx, which will be used as layout to our application

  ● Create a .container class on our global.css and use this class inside the main tag of div, and on other classes to
  maintain the width

  ● For excluding candidates, the delete candidate function could not belong to the list of candidates, since it do not
  "own" the state. Therefore, what we have to pass down a function to the children for indirect communication.

  ● After finishing the frontend project, there are several ways we can scale it to also include a separate backend
  project

    ○ In the project root, create a package.jon file outside of all individual projects, and use Node's workspace feature
      ■ a folder that contains multiple projects. This allows us to create both the frontend and backend, as well as share
      share code between them. A common approach is to have a core folder, which does not contain any application or
      framework-specific logic, but only utility libraries such as `uuid`. This way we can keep our business rules in one
      place and use them separately in different applications.
      ■ There also an option of placing every project into an apps folder and within package.json workspace simply use
      workspaces: ["apps/*"], since apps will not be considered a node project in the workspace
      ■ It will be a project in a single repository with both the applications that are going to be deployed, and also
      internal packages that we are willing to reuse between projects.

      ■ This node workspace is similar to turborepo, however, turborepo automates some things, such as separating consoles
      for each application being ran.
        □ Behind the curtains turbo-repo uses node workspaces. But adds some other features.

      ■ We will also create a packages folder for holding the core module and our graphics, and initially, it will be
      {
        "name": "urna",
        "version": "1.0.0",
        "workspaces": [
          "apps/*",
          "packages/*"
        ]
      }

      ■ Within the core package, in the package.json, we need to make the main property to point to the main attribute of
       our package
        □ to understand how a function from a project, is available to other applications, we will follow these steps
          1 - Create a simple function inside the main file of printing a string
          2 - Within the frontend's package.json, we are now going to treat the core package as a dependency package and
          use the name defined in core's package.json. Since we now depend on the core package, we simply add something
          like: 

            "dependencies": {
              "@urna/core": "*",
              ...
            }

          3 - And to make use of it, within our project root, outside all apps, install this package with npm install,
          since even though it is an internal package, it needs to make the necessary adjustements

          4 - We can now import the function exported by core, simply as importing a normal library as we are used to.
      
          5 - For running all apps at once, inside the outer package.json, we can install a library named `npm-run-all`
          and create new scrips

            . dev script where it runs in paralell all the scripts that start with dev, with a run-p dev:* , this will
            make it unnecessary to go into each folder and run the dev script

            . we can also explicitly say that a dev:frontend script will go into the frontend folder and run the dev
            with "cd apps/frontend && npm run dev"

            . with the dev script running in parallel all dev scripts from the workspaces, we run all together

  ● Layout errors

    ○ I, personally, faced  an error, where i was not sure how to place the layouts correctly, and this is going to be
    registered for me to not make the same mistake again

    ○ In Next.js App router, only the root layout `app/layout.tsx` is responsible for defining the <html> and <body> tags
    of the entire application, and here are some mistakes we can make

      ■ 1 - Creating the app/layout.tsx  like

        ```ts
          export default function RootLayout({
              children,
          }: Readonly<{
              children: React.ReactNode
          }>) {
              return (
                  <html lang="pt-BR">
                      <div>{children}</div>
                  </html>
              )
          }
        ```

      □ Here we end up defining an invalidHTML, since div was directly inside html without a <body> tag between\

      □ Browsers will ttry to fix this automatically by inserting a <body> element for us, but this breaks the expected
      structure of the App.ROuter in particular

        1. Next.js expects the body tag to be in our root layout, so it can properly inject scripts
        2. Skipping <body> means our layout is technically malformed
        3. Adding <html> in route-group layouts (like `(admin)/layout.tsx`) makes the problem worse because we'd be trying
        to render a full HTML document inside another HTML document, which is invalid
    
    ■ Correct approach

      □ define <html> and <body> exactly one in the app — In the root layout
      □ Any nested layouts, like the admin one, do not use <html><body>, just wrap the children in UI structure components,
      such as Page
      □ This will avoid hydration errors by Next.js

● Specific Components

  ○ One important thing when creating specific components, is not to limit its uses by taking off everything that one component
  has, its flexibility. When defining the properties of a button component we've created, for example, it is important to
  us to, in the interface, consider all existing properties within a button and place them inside our button so it can
  support all these necessities.
    This is why the instructor often follows the approach of creeating a specific component, but since in the app we're
  building, the goal is to simplify most of it, he ended up having the idea of creating a css class to be used inside purely
  html tags.

● Wrapping the main layout with the Context Provider

  ○ This is not considered the best approach, in the ideal scenario we would transform the layout return to be a client
  component, for this, we are going to create a folder (paginas) and place all our routs inside of this folder

  ○ We are going to do this, because this way, we can create a single layout file for all the pages within the app, this
  layout is going to be a client one since it will use a context provider

● Should the User model be an interface or a class? 

  ○ The user model, which in the beginning as an interface, usually it is a class. But for simplifying the code at the
  first moment, we are going to use it as an interface.
    
  ○ One question that may arise is: "Ok, now, how i will create this class?". If we just create a class with attributes
  and get/set methods, at the end of the day, it is basically the same as an interface, but if we want to insert some
  rich behaviors (methods), it makes more sense to turn it into a class that represent that model.

● Context function

  ○ If we define a function to update some state data, and this function is defined to have the same type as the useState
  is typed, if no further processing is done to the parameter, we can simply use this setter function as the function

  e.g.

    ■ const [usuario, setUsuario] = useState<Partial<Usuario>>({} as any);
      □ state is typed as a partial user

    ■ 	alterarUsuario: (usuario: Partial<Usuario>);
      □ Context properties have a function with the same type as the state

    ■ on the values object, passed to the provider we can simply
    value={{
				usuario,
				alterarUsuario: setUsuario,
			}}

  ○ Basically, when we do const [usuario, setUsuario] = useState<Partial<Usuario>>({} as any). React infers it as

    ■ usuario: Partial<User>; setUser: React.Dispatch<React.SetStateAction<Partial<User>>>;
    ■ Which means that the setUser is not only a function which receives a Partial<User>, it actually has the signature
    of: 
      □ type SetUsuario = (value: Partial<Usuario> | ((prev: Partial<Usuario>) => Partial<Usuario>)) => void;
      □ This means that we can directly pass a Partial<Usuario> object with, for example, setUser({ name: "Caio"});
      □ Or a function that receives the older state setUser(prev => {...prev, age: 29})

    ■ Inside the context, we define that the alterarUsuario is a function that receives a Partial<Usuario> and does not
    return anything

    ■ So, in the end, it makes sense using the setUser as the same function because setUsuario is more generic than the
    alterarUsuario typing
      □ setUsuario accepts a Partial<Usuario> or a function
      □ alterarUsuario accepts only a Partial<Usuario>
      □ Therefore, when we pass this function in the context value for the alterarUsuario, ts accepts it because any place
      that expects for a user: Partial<Usuario> can receive the setUser, since passing a partial is a case it accepts. it
      is just like a subset of a bigger function

    ■ In summary we can use setUsuario because its typing of Dispatch<SetStateAction<T>> is broader than the one which
    alterarUsuario typed. Since it accepts a Partial<Usuario> directly, ts considers it valid

  ○ Input blocked when using different state for the same input value

    ■ 1. We have two different states for the same input
      □ Created a local state for password, with a useState
      □ But in the value of the input, we are not using this password, but the property password of another object

    ■ 2. React locks the input because it is controlled
      □ A controlled <input> in React should have its value tied to the same state we update in onChange

    ■ To fix it, we just need to bind the value to the same state we're updating








